// generateIconTypes.ts
import * as fs from 'fs';

// 读取同级目录下的配置文件
const configContent = fs.readFileSync('src/components/FontIcon/iconfont.json', 'utf-8');
const config = JSON.parse(configContent);

console.log(`📦 Found ${config.glyphs.length} icons`);

// 生成 IconName 类型
const iconNames = config.glyphs.map(glyph => `'${glyph.font_class}'`);
let iconNameType = 'export type IconName =\n';
iconNames.forEach((name, index) => {
  if (index === iconNames.length - 1) {
    iconNameType += `  | ${name};`;
  } else {
    iconNameType += `  | ${name}\n`;
  }
});

// 生成图标配置
const iconMappings = config.glyphs
  .map(glyph => `  '${glyph.font_class}': ${glyph.unicode_decimal},`)
  .join('\n');

const iconConfigObject = `export const iconConfig: IconConfig = {
  fontFamily: '${config.font_family}',
  icons: {
${iconMappings}
  }
};`;

// 生成完整文件内容
const typeFileContent = `// Auto-generated icon types
// Do not edit this file manually

${iconNameType}

export interface IconConfig {
  fontFamily: string;
  icons: Record<IconName, number>;
}

${iconConfigObject}
`;

// 写入同级目录下的 icons.ts 文件
fs.writeFileSync('src/components/FontIcon/type.ts', typeFileContent, 'utf-8');

console.log('✅ Generated type.ts successfully!');
console.log(`📊 Generated types for ${config.glyphs.length} icons:`);
config.glyphs.forEach((glyph, index) => {
  console.log(`  ${index + 1}. ${glyph.font_class}`);
});
