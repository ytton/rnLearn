// generateIconTypes.ts
import * as fs from 'fs';

// è¯»å–åŒçº§ç›®å½•ä¸‹çš„é…ç½®æ–‡ä»¶
const configContent = fs.readFileSync('src/components/FontIcon/iconfont.json', 'utf-8');
const config = JSON.parse(configContent);

console.log(`ğŸ“¦ Found ${config.glyphs.length} icons`);

// ç”Ÿæˆ IconName ç±»å‹
const iconNames = config.glyphs.map(glyph => `'${glyph.font_class}'`);
let iconNameType = 'export type IconName =\n';
iconNames.forEach((name, index) => {
  if (index === iconNames.length - 1) {
    iconNameType += `  | ${name};`;
  } else {
    iconNameType += `  | ${name}\n`;
  }
});

// ç”Ÿæˆå›¾æ ‡é…ç½®
const iconMappings = config.glyphs
  .map(glyph => `  '${glyph.font_class}': ${glyph.unicode_decimal},`)
  .join('\n');

const iconConfigObject = `export const iconConfig: IconConfig = {
  fontFamily: '${config.font_family}',
  icons: {
${iconMappings}
  }
};`;

// ç”Ÿæˆå®Œæ•´æ–‡ä»¶å†…å®¹
const typeFileContent = `// Auto-generated icon types
// Do not edit this file manually

${iconNameType}

export interface IconConfig {
  fontFamily: string;
  icons: Record<IconName, number>;
}

${iconConfigObject}
`;

// å†™å…¥åŒçº§ç›®å½•ä¸‹çš„ icons.ts æ–‡ä»¶
fs.writeFileSync('src/components/FontIcon/type.ts', typeFileContent, 'utf-8');

console.log('âœ… Generated type.ts successfully!');
console.log(`ğŸ“Š Generated types for ${config.glyphs.length} icons:`);
config.glyphs.forEach((glyph, index) => {
  console.log(`  ${index + 1}. ${glyph.font_class}`);
});
